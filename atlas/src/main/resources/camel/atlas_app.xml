<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:jee="http://www.springframework.org/schema/jee"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jpa="http://www.springframework.org/schema/data/jpa"
       xsi:schemaLocation="http://www.springframework.org/schema/aop
                           http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
                           http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
                           http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-2.5.xsd
                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
                           http://camel.apache.org/schema/spring
                           http://camel.apache.org/schema/spring/camel-spring-2.16.1.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">


    <!-- have a properties file with the defaults with the possibility to override them with
         JRE or system environment variables-->
    <bean id="bridgePropertyPlaceholder"
          class="org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer">
        <property name="location" value="classpath:atlas.properties"/>
        <property name="systemPropertiesModeName" value="SYSTEM_PROPERTIES_MODE_OVERRIDE"/>
        <property name="searchSystemEnvironment" value="true"/>
    </bean>

    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close">
        <property name="driverClass" value="org.postgresql.Driver"/>
        <property name="jdbcUrl" value="${psql.url}"/>
        <property name="user" value="${psql.user}"/>
        <property name="password" value="${psql.pass}"/>
        <property name="maxPoolSize" value="5"/>
        <property name="minPoolSize" value="1"/>
    </bean>

    <bean id="populateProperties" class="org.georchestra.atlas.CamelPopulatePropertiesComponent"/>

    <bean id="setState" class="org.georchestra.atlas.CamelSetStateComponent"/>

    <!--<bean id="myTransactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">-->
      <!--<property name="entityManagerFactory" ref="entityManagerFactory"/>-->
    <!--</bean>-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>


    <bean id="jpa" class="org.apache.camel.component.jpa.JpaComponent">
        <property name="entityManagerFactory" ref="entityManagerFactory"/>
        <property name="transactionManager" ref="transactionManager"/>
    </bean>

    <bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
        <property name="persistenceUnitName" value="myPU"/>
        <property name="dataSource" ref="dataSource"/>
        <property name="jpaProperties">
            <props>
                <prop key="hibernate.dialect">org.hibernate.dialect.PostgreSQL94Dialect</prop>
                <prop key="hibernate.show_sql">false</prop>
                <prop key="hibernate.format_sql">false</prop>
                <prop key="hibernate.hbm2ddl.auto">update</prop>
            </props>
        </property>

    </bean>

    <!-- A context component that has some utility components to handle typical tasks -->
    <camelContext id="atlas" xmlns="http://camel.apache.org/schema/spring"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                  streamCache="true">

        <routeContextRef ref="mapfish"/>

        <restConfiguration component="servlet">
            <componentProperty key="enableCors" value="true"/>
            <dataFormatProperty key="prettyPrint" value="true"/>
        </restConfiguration>

        <!--
        Route for requesting Mapfish Print to generate a PDF.
        Inputs:
            - the body must contain the JSON request.
            - property.printBase must have the base URL of the Mapfish Print service.
        -->
        <rest>
            <post uri="/atlas/print" consumes="application/json" produces="application/json" enableCORS="true">
                <to uri="direct:save_print_request"/>
            </post>
        </rest>

        <route id="save_print_request">
            <from uri="direct:save_print_request"/>

            <to uri="direct:checkArgs"/>

            <!-- store in DB queue -->
            <to uri="jpa:org.georchestra.atlas.AtlasJob?persistenceUnit=myPU"/>

            <log message="Storing request to DB with ID : ${body.id}" loggingLevel="INFO"/>

            <transform>
                <simple>${body.id}</simple>
            </transform>

        </route>

        <route id="checkArgs">
            <from uri="direct:checkArgs"/>

            <!-- check json format -->
            <unmarshal ref="gson"/>
            <marshal ref="gson"/>

        </route>


        <route id="split_and_send_request">
            <from uri="jpa:org.georchestra.atlas.AtlasJob?transactionManager=#transactionManager&amp;persistenceUnit=myPU&amp;consumer.lockModeType=NONE&amp;consumer.delay=2000&amp;maximumResults=1&amp;consumeDelete=false&amp;consumer.query=FROM org.georchestra.atlas.AtlasJob WHERE state = 'TODO' ORDER BY id"/>

            <log message="New request from DB" loggingLevel="INFO"/>

            <setProperty propertyName="dummy">
                <groovy>request.body.setState(org.georchestra.atlas.AtlasJobState.IN_PROGRESS)</groovy>
            </setProperty>

            <setProperty propertyName="jobId">
                <simple>${body.id}</simple>
            </setProperty>

            <!-- Store job as object -->
            <setProperty propertyName="originalObject">
                <simple>${body}</simple>
            </setProperty>

            <transform>
                <groovy>request.body.getQuery()</groovy>
            </transform>

            <!-- Backup original Json-->
            <setProperty propertyName="rawJson">
                <simple>${body}</simple>
            </setProperty>

            <!-- parse json -->
            <unmarshal ref="gson"/>

            <setProperty propertyName="layout">
                <simple>${body[layout]}</simple>
            </setProperty>

            <setProperty propertyName="dpi">
                <simple>${body[dpi]}</simple>
            </setProperty>

            <setProperty propertyName="displayLegend">
                <simple>${body[displayLegend]}</simple>
            </setProperty>

            <setProperty propertyName="outputFormat">
                <simple>${body[outputFormat]}</simple>
            </setProperty>

            <setProperty propertyName="outputFilename">
                <simple>${body[outputFilename]}</simple>
            </setProperty>

            <setProperty propertyName="projection">
                <simple>${body[projection]}</simple>
            </setProperty>

            <!-- generate layers and legendURL property -->
            <to uri="bean:populateProperties"/>

            <split stopOnException="true">
                <simple>${body[pages]}</simple>
                <choice>
                    <when>
                        <simple>${exchangeProperty.displayLegend} == true</simple>
                        <transform>
                            <simple>
                                { "layout": "${exchangeProperty.layout}",
                                "outputFormat": "PDF",
                                "attributes": {
                                "title": "${body[title]}",
                                "subtitle": "${body[subtitle]}",
                                "legendURL": "${exchangeProperty.legendURL}",
                                "datasource": [{
                                "map": {
                                "dpi": ${exchangeProperty.dpi},
                                "projection": "${exchangeProperty.projection}",
                                "center": ${body[center]},
                                "scale": ${body[scale]},
                                "layers": ${exchangeProperty.layers}
                                }}]}}
                            </simple>
                        </transform>
                    </when>
                    <otherwise>
                        <transform>
                            <simple>
                                { "layout": "${exchangeProperty.layout}",
                                "outputFormat": "PDF",
                                "attributes": {
                                "title": "${body[title]}",
                                "subtitle": "${body[subtitle]}",
                                "datasource": [{
                                "map": {
                                "dpi": ${exchangeProperty.dpi},
                                "projection": "${exchangeProperty.projection}",
                                "center": ${body[center]},
                                "scale": ${body[scale]},
                                "layers": ${exchangeProperty.layers}
                                }}]}}
                            </simple>
                        </transform>
                    </otherwise>
                </choice>

                <log message="print request : ${body}" loggingLevel="INFO"/>

                <setProperty propertyName="printBase">
                    <constant>http://print:8080/print/atlas</constant>
                </setProperty>

                <to uri="direct:print"/>

                <to uri="file://?fileName=/tmp/tmp/${property.jobId}/${property.CamelSplitIndex}.pdf"/>

                <log message="${property.jobId} / ${property.CamelSplitIndex} Done !" loggingLevel="INFO"/>

            </split>


            <setHeader headerName="CamelExecCommandWorkingDir">
                <simple>/tmp/tmp/${property.jobId}</simple>
            </setHeader>

            <!-- Clean STDIN before launching scripts -->
            <transform>
                <constant/>
            </transform>

            <choice>
                    <when>
                        <simple>${exchangeProperty.outputFormat} == "pdf"</simple>
                        <to uri="exec:/bin/sh?useStderrOnEmptyStdout=true&amp;args=-c &quot;/usr/bin/pdfjoin --outfile /proc/self/fd/1 *.pdf&quot;"/>
                    </when>
                    <otherwise>
                        <to uri="exec:/bin/sh?useStderrOnEmptyStdout=true&amp;args=-c &quot;/usr/bin/zip - *.pdf&quot;"/>
                    </otherwise>
            </choice>

            <choice>
                <when>
                    <simple>${body.exitValue} != 0</simple>
                    <to uri="log:zip?level=ERROR"/>
                    <throwException message="Failed to zip the files" exceptionType="java.lang.RuntimeException"/>
                </when>
                <otherwise>
                    <to uri="file://?fileName=/tmp/output/${property.outputFilename}"/>
                </otherwise>
            </choice>

            <transform>
                <simple>${property.originalObject}</simple>
            </transform>

            <!-- Change state of job -->
            <setProperty propertyName="dummy">
                <groovy>request.body.setState(org.georchestra.atlas.AtlasJobState.DONE)</groovy>
            </setProperty>

        </route>


        <!--<route id="split_save">-->
            <!--<from uri="direct:split_save"/>-->

            <!--&lt;!&ndash; Backup original Json&ndash;&gt;-->
            <!--<setProperty propertyName="rawJson">-->
                <!--<simple>${body}</simple>-->
            <!--</setProperty>-->

            <!--&lt;!&ndash; parse json &ndash;&gt;-->
            <!--<unmarshal ref="gson"/>-->

            <!--<setProperty propertyName="layout">-->
                <!--<simple>${body[layout]}</simple>-->
            <!--</setProperty>-->

            <!--<setProperty propertyName="dpi">-->
                <!--<simple>${body[dpi]}</simple>-->
            <!--</setProperty>-->

            <!--<setProperty propertyName="displayLegend">-->
                <!--<simple>${body[displayLegend]}</simple>-->
            <!--</setProperty>-->

            <!--<setProperty propertyName="outputFormat">-->
                <!--<simple>${body[outputFormat]}</simple>-->
            <!--</setProperty>-->

            <!--<setProperty propertyName="projection">-->
                <!--<simple>${body[projection]}</simple>-->
            <!--</setProperty>-->

            <!--&lt;!&ndash; Generate unique identifier for atlas job &ndash;&gt;-->
            <!--<setProperty propertyName="uuid">-->
                <!--<groovy>java.util.UUID.randomUUID().toString()</groovy>-->
            <!--</setProperty>-->

            <!--&lt;!&ndash; generate layers and legendURL property &ndash;&gt;-->
            <!--<to uri="bean:populateProperties"/>-->

            <!--<split stopOnException="true">-->
                <!--<simple>${body[pages]}</simple>-->
                <!--<choice>-->
                    <!--<when>-->
                        <!--<simple>${exchangeProperty.displayLegend} == true</simple>-->
                        <!--<transform>-->
                            <!--<simple>-->
                                <!--{ "layout": "${exchangeProperty.layout}",-->
                                <!--"outputFormat": "PDF",-->
                                <!--"attributes": {-->
                                <!--"title": "${body[title]}",-->
                                <!--"subtitle": "${body[subtitle]}",-->
                                <!--"legendURL": "${exchangeProperty.legendURL}",-->
                                <!--"datasource": [{-->
                                <!--"map": {-->
                                <!--"dpi": ${exchangeProperty.dpi},-->
                                <!--"projection": "${exchangeProperty.projection}",-->
                                <!--"center": ${body[center]},-->
                                <!--"scale": ${body[scale]},-->
                                <!--"layers": ${exchangeProperty.layers}-->
                                <!--}}]}}-->
                            <!--</simple>-->
                        <!--</transform>-->
                    <!--</when>-->
                    <!--<otherwise>-->
                        <!--<transform>-->
                            <!--<simple>-->
                                <!--{ "layout": "${exchangeProperty.layout}",-->
                                <!--"outputFormat": "PDF",-->
                                <!--"attributes": {-->
                                <!--"title": "${body[title]}",-->
                                <!--"subtitle": "${body[subtitle]}",-->
                                <!--"datasource": [{-->
                                <!--"map": {-->
                                <!--"dpi": ${exchangeProperty.dpi},-->
                                <!--"projection": "${exchangeProperty.projection}",-->
                                <!--"center": ${body[center]},-->
                                <!--"scale": ${body[scale]},-->
                                <!--"layers": ${exchangeProperty.layers}-->
                                <!--}}]}}-->
                            <!--</simple>-->
                        <!--</transform>-->
                    <!--</otherwise>-->
                <!--</choice>-->


                <!--&lt;!&ndash; Test Json validity &ndash;&gt;-->
                <!--&lt;!&ndash;<marshal ref="gson"/>&ndash;&gt;-->
                <!--&lt;!&ndash;<unmarshal ref="gson"/>&ndash;&gt;-->

                <!--<log message="${body}" loggingLevel="ERROR"/>-->

                <!--&lt;!&ndash;<marshal ref="gson"/>&ndash;&gt;-->
                <!--<to uri="file:///tmp/log?autoCreate=true"/>-->

                <!--&lt;!&ndash; store in DB queue &ndash;&gt;-->
                <!--<to uri="hibernate:org.georchestra.atlas.AtlasMFPJob"/>-->

            <!--</split>-->

        <!--</route>-->

        <!--<route id="start_generation">-->
            <!--<from uri="hibernate:org.georchestra.atlas.AtlasMFPJob?consumer.delay=2000&amp;maximumResults=1&amp;consumeDelete=false&amp;consumer.query=FROM org.georchestra.atlas.AtlasMFPJob WHERE state = 'TODO' ORDER BY id"/>-->

            <!--<to uri="bean:setState?method=setInProgress"/>-->

            <!--<log message="${body}" loggingLevel="ERROR"/>-->
            <!--<transform>-->
                <!--<groovy>request.body.getQuery()</groovy>-->
            <!--</transform>-->
            <!--<setProperty propertyName="printBase">-->
                <!--<constant>http://print:8080/print/atlas</constant>-->
            <!--</setProperty>-->

            <!--<to uri="direct:print"/>-->

        <!--</route>-->


    </camelContext>



</beans>
